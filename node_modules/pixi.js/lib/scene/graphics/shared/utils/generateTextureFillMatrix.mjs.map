{"version":3,"file":"generateTextureFillMatrix.mjs","sources":["../../../../../src/scene/graphics/shared/utils/generateTextureFillMatrix.ts"],"sourcesContent":["import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { FillGradient } from '../fill/FillGradient';\n\nimport type { ShapePrimitive } from '../../../../maths/shapes/ShapePrimitive';\nimport type { FillStyle, StrokeStyle } from '../FillTypes';\n\n/**\n * Temporary matrix used for matrix calculations\n * @internal\n */\nconst tempTextureMatrix = new Matrix();\n\n/**\n * Temporary rectangle used for bounds calculations\n * @internal\n */\nconst tempRect = new Rectangle();\n\n/**\n * Generates a texture matrix for mapping textures onto shapes.\n * This function handles both local and global texture space mapping.\n *\n * In local space, the texture is mapped to fit exactly within the bounds of the shape.\n * In global space, the texture is mapped using its own dimensions and position.\n * @param out - The matrix to store the result in\n * @param style - The fill style containing texture and mapping properties\n * @param shape - The shape to map the texture onto\n * @param matrix - Optional transform matrix to apply\n * @returns The generated texture matrix for UV mapping\n * @example\n * ```ts\n * const matrix = new Matrix();\n * const textureMatrix = generateTextureMatrix(matrix, fillStyle, shape);\n * // textureMatrix now contains the proper UV mapping for the texture\n * ```\n */\nexport function generateTextureMatrix(out: Matrix, style: FillStyle | StrokeStyle, shape: ShapePrimitive, matrix?: Matrix)\n{\n    // Start with either the style's matrix inverted, or identity matrix\n    const textureMatrix = style.matrix\n        ? out.copyFrom(style.matrix).invert()\n        : out.identity();\n\n    if (style.textureSpace === 'local')\n    {\n        // For local space, map texture to shape's bounds\n        const bounds = shape.getBounds(tempRect);\n\n        if ((style as StrokeStyle).width)\n        {\n            bounds.pad((style as StrokeStyle).width);\n        }\n\n        const { x: tx, y: ty } = bounds;\n        const sx = 1 / bounds.width;\n        const sy = 1 / bounds.height;\n\n        const mTx = -tx * sx;\n        const mTy = -ty * sy;\n\n        const a1 = textureMatrix.a;\n        const b1 = textureMatrix.b;\n        const c1 = textureMatrix.c;\n        const d1 = textureMatrix.d;\n\n        textureMatrix.a *= sx;\n        textureMatrix.b *= sx;\n        textureMatrix.c *= sy;\n        textureMatrix.d *= sy;\n\n        textureMatrix.tx = (mTx * a1) + (mTy * c1) + textureMatrix.tx;\n        textureMatrix.ty = (mTx * b1) + (mTy * d1) + textureMatrix.ty;\n    }\n    else\n    {\n        // For global space, use texture's own dimensions\n        textureMatrix.translate(style.texture.frame.x, style.texture.frame.y);\n        textureMatrix.scale(1 / (style.texture.source.width), 1 / (style.texture.source.height));\n    }\n\n    const sourceStyle = style.texture.source.style;\n\n    // we don't want to set the address mode if the fill is a gradient as this handles its own address mode\n    if (!(style.fill instanceof FillGradient) && sourceStyle.addressMode === 'clamp-to-edge')\n    {\n        sourceStyle.addressMode = 'repeat';\n        sourceStyle.update();\n    }\n\n    // Apply any additional transform matrix\n    if (matrix)\n    {\n        textureMatrix.append(tempTextureMatrix.copyFrom(matrix).invert());\n    }\n\n    return textureMatrix;\n}\n"],"names":[],"mappings":";;;;;AAWA,MAAM,iBAAA,GAAoB,IAAI,MAAO,EAAA,CAAA;AAMrC,MAAM,QAAA,GAAW,IAAI,SAAU,EAAA,CAAA;AAoBxB,SAAS,qBAAsB,CAAA,GAAA,EAAa,KAAgC,EAAA,KAAA,EAAuB,MAC1G,EAAA;AAEI,EAAM,MAAA,aAAA,GAAgB,KAAM,CAAA,MAAA,GACtB,GAAI,CAAA,QAAA,CAAS,KAAM,CAAA,MAAM,CAAE,CAAA,MAAA,EAC3B,GAAA,GAAA,CAAI,QAAS,EAAA,CAAA;AAEnB,EAAI,IAAA,KAAA,CAAM,iBAAiB,OAC3B,EAAA;AAEI,IAAM,MAAA,MAAA,GAAS,KAAM,CAAA,SAAA,CAAU,QAAQ,CAAA,CAAA;AAEvC,IAAA,IAAK,MAAsB,KAC3B,EAAA;AACI,MAAO,MAAA,CAAA,GAAA,CAAK,MAAsB,KAAK,CAAA,CAAA;AAAA,KAC3C;AAEA,IAAA,MAAM,EAAE,CAAA,EAAG,EAAI,EAAA,CAAA,EAAG,IAAO,GAAA,MAAA,CAAA;AACzB,IAAM,MAAA,EAAA,GAAK,IAAI,MAAO,CAAA,KAAA,CAAA;AACtB,IAAM,MAAA,EAAA,GAAK,IAAI,MAAO,CAAA,MAAA,CAAA;AAEtB,IAAM,MAAA,GAAA,GAAM,CAAC,EAAK,GAAA,EAAA,CAAA;AAClB,IAAM,MAAA,GAAA,GAAM,CAAC,EAAK,GAAA,EAAA,CAAA;AAElB,IAAA,MAAM,KAAK,aAAc,CAAA,CAAA,CAAA;AACzB,IAAA,MAAM,KAAK,aAAc,CAAA,CAAA,CAAA;AACzB,IAAA,MAAM,KAAK,aAAc,CAAA,CAAA,CAAA;AACzB,IAAA,MAAM,KAAK,aAAc,CAAA,CAAA,CAAA;AAEzB,IAAA,aAAA,CAAc,CAAK,IAAA,EAAA,CAAA;AACnB,IAAA,aAAA,CAAc,CAAK,IAAA,EAAA,CAAA;AACnB,IAAA,aAAA,CAAc,CAAK,IAAA,EAAA,CAAA;AACnB,IAAA,aAAA,CAAc,CAAK,IAAA,EAAA,CAAA;AAEnB,IAAA,aAAA,CAAc,EAAM,GAAA,GAAA,GAAM,EAAO,GAAA,GAAA,GAAM,KAAM,aAAc,CAAA,EAAA,CAAA;AAC3D,IAAA,aAAA,CAAc,EAAM,GAAA,GAAA,GAAM,EAAO,GAAA,GAAA,GAAM,KAAM,aAAc,CAAA,EAAA,CAAA;AAAA,GAG/D,MAAA;AAEI,IAAc,aAAA,CAAA,SAAA,CAAU,MAAM,OAAQ,CAAA,KAAA,CAAM,GAAG,KAAM,CAAA,OAAA,CAAQ,MAAM,CAAC,CAAA,CAAA;AACpE,IAAc,aAAA,CAAA,KAAA,CAAM,CAAK,GAAA,KAAA,CAAM,OAAQ,CAAA,MAAA,CAAO,OAAQ,CAAK,GAAA,KAAA,CAAM,OAAQ,CAAA,MAAA,CAAO,MAAO,CAAA,CAAA;AAAA,GAC3F;AAEA,EAAM,MAAA,WAAA,GAAc,KAAM,CAAA,OAAA,CAAQ,MAAO,CAAA,KAAA,CAAA;AAGzC,EAAA,IAAI,EAAE,KAAM,CAAA,IAAA,YAAgB,YAAiB,CAAA,IAAA,WAAA,CAAY,gBAAgB,eACzE,EAAA;AACI,IAAA,WAAA,CAAY,WAAc,GAAA,QAAA,CAAA;AAC1B,IAAA,WAAA,CAAY,MAAO,EAAA,CAAA;AAAA,GACvB;AAGA,EAAA,IAAI,MACJ,EAAA;AACI,IAAA,aAAA,CAAc,OAAO,iBAAkB,CAAA,QAAA,CAAS,MAAM,CAAA,CAAE,QAAQ,CAAA,CAAA;AAAA,GACpE;AAEA,EAAO,OAAA,aAAA,CAAA;AACX;;;;"}
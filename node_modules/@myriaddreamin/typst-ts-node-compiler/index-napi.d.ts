/* auto-generated by NAPI-RS */ /* eslint-disable */ import type * as types from './index.js';/**
 * A nullable boxed compiler wrapping.
 *
 * This is for transferring boxed compiler between functions.
 * It will panic if the inner boxed compiler is already taken.
 */
export declare class BoxedCompiler {

}
export type JsBoxedCompiler = BoxedCompiler

export declare class DynLayoutCompiler {
  /** Creates a new compiler based on the given arguments. */
  static fromBoxed(b: JsBoxedCompiler): DynLayoutCompiler
  /** Sets the target of the compiler. */
  setTarget(target: string): void
  /** Specifies width (in pts) of the layout. */
  setLayoutWidths(layoutWidths: Array<number>): void
  /** Exports the document as a vector IR containing multiple layouts. */
  vector(compileBy: CompileDocArgs): Buffer
}

/** Node wrapper to access compiler interfaces. */
export declare class NodeCompiler {
  /**
   * Creates a new compiler based on the given arguments.
   *
   * == Example
   *
   * Creates a new compiler with default arguments:
   * ```ts
   * const compiler = NodeCompiler.create();
   * ```
   *
   * Creates a new compiler with custom arguments:
   * ```ts
   * const compiler = NodeCompiler.create({
   *   workspace: '/path/to/workspace',
   * });
   * ```
   */
  static create(args?: CompileArgs): NodeCompiler
  /** Casts the inner compiler. */
  static fromBoxed(b: JsBoxedCompiler): NodeCompiler
  /** Takes ownership of the inner compiler. */
  intoBoxed(): JsBoxedCompiler
  /**
   * Evict the **global** cache.
   *
   * This removes all memoized results from the cache whose age is larger
   * than or equal to `max_age`. The age of a result grows by one during
   * each eviction and is reset to zero when the result produces a cache
   * hit. Set `max_age` to zero to completely clear the cache.
   *
   * A suggested `max_age` value for regular non-watch tools is `10`.
   * A suggested `max_age` value for regular watch tools is `30`.
   */
  evictCache(maxAge: number): void
  /**
   * Adds a source file to the compiler.
   * @param path - The path of the source file.
   * @param source - The source code of the source file.
   */
  addSource(path: string, source: string): void
  /**
   * Adds a shadow file to the compiler.
   * @param path - The path to the shadow file.
   * @param content - The content of the shadow file.
   */
  mapShadow(path: string, content: Buffer): void
  /**
   * Removes a shadow file from the compiler.
   * @param path - The path to the shadow file.
   */
  unmapShadow(path: string): void
  /**
   * Resets the shadow files.
   * Note: this function is independent to the {@link reset} function.
   */
  resetShadow(): void
  /** Compiles the document as paged target. */
  compile(opts: CompileDocArgs): NodeTypstCompileResult
  /** Compiles the document as html target. */
  compileHtml(opts: CompileDocArgs): NodeTypstCompileResult
  /** Fetches the diagnostics of the document. */
  fetchDiagnostics(opts: NodeError): Array<any>
  /** Queries the data of the document. */
  query(compiledOrBy: NodeTypstDocument | CompileDocArgs, args: QueryDocArgs): any
  /** Simply compiles the document as a vector IR. */
  vector(compiledOrBy: NodeTypstDocument | CompileDocArgs): Buffer
  /** Simply compiles the document as a PDF. */
  pdf(compiledOrBy: NodeTypstDocument | CompileDocArgs, opts?: RenderPdfOpts): Buffer
  /** Simply compiles the document as a plain SVG. */
  plainSvg(compiledOrBy: NodeTypstDocument | CompileDocArgs): string
  /** Simply compiles the document as a rich-contented SVG (for browsers). */
  svg(compiledOrBy: NodeTypstDocument | CompileDocArgs): string
  /** Simply compiles the document as a HTML. */
  html(compiledOrBy: NodeTypstDocument | CompileDocArgs): string | null
  /** Compiles the document as a HTML. */
  tryHtml(compiledOrBy: NodeTypstDocument | CompileDocArgs): NodeHtmlOutputExecResult
}

/** A node error. */
export declare class NodeError {
  /** Gets the kind of the error. */
  get kind(): string
  /**
   * Gets the short diagnostics of the error.
   *
   * To retrieve the full diagnostics, please use
   * `NodeCompiler.fetch_diagnostics`.
   */
  get shortDiagnostics(): Array<any>
  /**
   * Gets the compilation status
   *
   * If the error is an error, it will return `internal_error`.
   *
   * Otherwise, if diagnostics contains any error, it will return `error`.
   *
   * Otherwise, if diagnostics contains any warning, it will return
   * `warning`.
   *
   * Otherwise, it will return `ok`.
   */
  get compilationStatus(): string
}

/** A shared HTML output object. */
export declare class NodeHtmlOutput {
  /** Gets the title of the document. */
  title(): string | null
  /** Gets the description of the document. */
  description(): string | null
  /** Gets the body of the document. */
  body(): string
  /** Gets the body of the document as bytes. */
  bodyBytes(): Buffer
  /** Gets the HTML of the document. */
  html(): string
  /** Gets the HTML of the document as bytes. */
  htmlBytes(): Buffer
}

export declare class NodeHtmlOutputExecResult {
  /** Gets the result of execution. */
  get result(): NodeHtmlOutput | null
  /** Takes the result of execution. */
  takeWarnings(): NodeError | null
  /** Takes the error of execution. */
  takeError(): NodeError | null
  /** Takes the diagnostics of execution. */
  takeDiagnostics(): NodeError | null
  /** Whether the execution has error. */
  hasError(): boolean
  /** Prints the errors during execution. */
  printErrors(): void
  /** Prints the diagnostics of execution. */
  printDiagnostics(): void
}

export declare class NodeTypstCompileResult {
  /** Gets the result of execution. */
  get result(): NodeTypstDocument | null
  /** Takes the result of execution. */
  takeWarnings(): NodeError | null
  /** Takes the error of execution. */
  takeError(): NodeError | null
  /** Takes the diagnostics of execution. */
  takeDiagnostics(): NodeError | null
  /** Whether the execution has error. */
  hasError(): boolean
  /** Prints the errors during execution. */
  printErrors(): void
  /** Prints the diagnostics of execution. */
  printDiagnostics(): void
}

/** A shared typst document object. */
export declare class NodeTypstDocument {
  /** Gets the number of pages in the document. */
  get numOfPages(): number
  /** Gets the title of the document. */
  get title(): string | null
  /** Gets the authors of the document. */
  get authors(): Array<string> | null
  /** Gets the keywords of the document. */
  get keywords(): Array<string> | null
  /**
   * Gets the unix timestamp (in nanoseconds) of the document.
   *
   * Note: currently typst doesn't specify the timezone of the date, and we
   * keep stupid and doesn't add timezone info to the date.
   */
  get date(): number | null
  /**
   * Determines whether the date should be automatically generated.
   *
   * This happens when user specifies `date: auto` in the document
   * explicitly.
   */
  get enabledAutoDate(): boolean
}

export declare class NodeTypstProject {
  /** Compiles the document as paged target. */
  compile(opts: CompileDocArgs): NodeTypstCompileResult
  /** Compiles the document as html target. */
  compileHtml(opts: CompileDocArgs): NodeTypstCompileResult
  /** Fetches the diagnostics of the document. */
  fetchDiagnostics(opts: NodeError): Array<any>
  /** Queries the data of the document. */
  query(compiledOrBy: NodeTypstDocument | CompileDocArgs, args: QueryDocArgs): any
  /** Simply compiles the document as a vector IR. */
  vector(compiledOrBy: NodeTypstDocument | CompileDocArgs): Buffer
  /** Simply compiles the document as a PDF. */
  pdf(compiledOrBy: NodeTypstDocument | CompileDocArgs, opts?: RenderPdfOpts): Buffer
  /** Simply compiles the document as a plain SVG. */
  plainSvg(compiledOrBy: NodeTypstDocument | CompileDocArgs): string
  /** Simply compiles the document as a rich-contented SVG (for browsers). */
  svg(compiledOrBy: NodeTypstDocument | CompileDocArgs): string
  /** Simply compiles the document as a HTML. */
  html(compiledOrBy: NodeTypstDocument | CompileDocArgs): string | null
  /** Compiles the document as a HTML. */
  tryHtml(compiledOrBy: NodeTypstDocument | CompileDocArgs): NodeHtmlOutputExecResult
}

/** Project watcher. */
export declare class ProjectWatcher {
  /**
   * Creates a new compiler based on the given arguments.
   *
   * == Example
   *
   * Creates a new compiler with default arguments:
   * ```ts
   * const compiler = ProjectCompiler.create();
   * ```
   *
   * Creates a new compiler with custom arguments:
   * ```ts
   * const compiler = ProjectCompiler.create({
   *   workspace: '/path/to/workspace',
   * });
   * ```
   */
  static create(args?: CompileArgs | undefined | null): ProjectWatcher
  /**
   * Evict the **global** cache.
   *
   * This removes all memoized results from the cache whose age is larger
   * than or equal to `max_age`. The age of a result grows by one during
   * each eviction and is reset to zero when the result produces a cache
   * hit. Set `max_age` to zero to completely clear the cache.
   *
   * A suggested `max_age` value for regular non-watch tools is `10`.
   * A suggested `max_age` value for regular watch tools is `30`.
   */
  evictCache(maxAge: number): void
  /**
   * Watches multiple documents for changes.
   *
   * == Example
   *
   * Watches and updates multiple documents for changes:
   * ```ts
   * const compiler = ProjectCompiler.create();
   * compiler.update(['a.typ', 'b.typ'], console.log);
   * compiler.watch();
   *
   * compiler.update([{ main: 'a.typ', workspace: '..' }], console.log);
   * // watch again will flush changes cancel the previous watch
   * compiler.watch();
   * ```
   *
   * Glob patterns watches:
   * ```ts
   * const watch = require('glob-watcher');
   * const compiler = ProjectCompiler.create();
   *
   * const onChange = (project) => console.log(project);
   *
   * const watcher = watch(['./*.typ', '!./something.typ']);
   * watcher.on('add', (path) => {
   *   compiler.add(path, onChange); compiler.watch();
   * });
   * watcher.on('remove', (path) => {
   *   compiler.remove(path, onChange); compiler.watch();
   * });
   * ```
   */
  watch(): void
  /** Adds multiple documents to the compiler. */
  add(items: types.ProjectWatchItems, callback: (project: NodeTypstProject) => void): void
  /** Updates multiple documents in the compiler. */
  update(items: types.ProjectWatchItems, callback: (project: NodeTypstProject) => void): void
  /** Removes multiple documents from the compiler. */
  remove(items: types.ProjectWatchItems): void
  /** Clears all documents in the compiler. */
  clear(): void
  /** Gets the list of documents in the compiler. */
  list(): Array<string>
}

export interface CompileArgs {
  /** Adds additional directories to search for fonts */
  fontArgs?: Array<NodeAddFontPaths | NodeAddFontBlobs>
  /** Path to typst workspace. */
  workspace?: string
  /** Adds a string key-value pair visible through `sys.inputs` */
  inputs?: Record<string, string>
}

/**
 * The arguments to compile a document.
 *
 * If no `mainFileContent` or `mainFilePath` is specified, the compiler will
 * use the entry file specified in the constructor of `NodeCompiler`.
 */
export interface CompileDocArgs {
  /**
   * Specifies the main file content.
   * Exclusive with `mainFilePath`.
   */
  mainFileContent?: string
  /**
   * Specifies path to the entry file.
   * Exclusive with `mainFileContent`.
   */
  mainFilePath?: string
  /** Passes `sys.inputs` as is in format of string key-value pairs. */
  inputs?: Record<string, string>
  /** (Experimental) Whether to reset the cache before compilation. */
  resetRead?: boolean
}

export interface NodeAddFontBlobs {
  /** Adds additional memory fonts */
  fontBlobs: Array<Buffer>
}

export interface NodeAddFontPaths {
  /** Adds additional directories to search for fonts */
  fontPaths: Array<string>
}

/** Arguments to query the document. */
export interface QueryDocArgs {
  /** The query selector. */
  selector: string
  /** An optional field to select on the element of the resultants. */
  field?: string
}

/** Arguments to render a PDF. */
export interface RenderPdfOpts {
  /**
   * (Experimental) An optional PDF standard to be used to export PDF.
   *
   * Please check {@link types.PdfStandard} for a non-exhaustive list of
   * standards.
   */
  pdfStandard?: string
  /**
   * An optional (creation) timestamp to be used to export PDF, *in seconds*.
   *
   * This is used when you *enable auto timestamp* in the document.
   */
  creationTimestamp?: number
}
